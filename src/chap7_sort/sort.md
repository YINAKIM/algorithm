
**정렬이란?**   
* key값의 대소관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
* 오름차순 : 왼쪽 값 < 오른쪽 값 
* 내림차순 : 왼쪽 값 > 오른쪽 값
* 안정된 정렬 : 이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것 (중복값이 있을 경우 안정되지 않을 수 있음)
* 패스 : 정렬을 위한 비교-교환작업 일련의 과정

<aside>
💡핵심요소 : 교환, 선택, 삽입   
</aside>

---

**내부정렬 / 외부정렬**   
  하나의 배열에서 작업 가능한 경우 내부정렬 사용, 하나의 배열에서 작업 불가능한 경우 외부정렬 사용
  - 내부정렬(internal sorting) : 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우 사용
  - 외부정렬(external sorting) : 정렬할 데이터가 너무 많아 하나의 배열에 저장할 수 없는 경우 사용

**정렬의 종류**

### 1. 버블 정렬(bubble sort)
- 이웃한 두 요소의 대소관계를 비교하여 교환을 반복
- 패스(pass) : 요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고나면 가장작은 요소가 맨 처음으로 이동하는 **일련의 과정(비교,교환 작업)**
```java
for(int i=0; i < n-1; i++){
    // a[i], a[i+1], ... ,a[n-1] 에 대해 끝에서부터 앞쪽으로 스캔하면서 이웃하는 두 요소를 비교하고 교환
    // 
}
```

### 2. 선택 정렬(selection sort)
- 가장 작은 요소부터 선택해, 알맞은 위치로 옮겨서 순서대로 정렬
- 단순선택정렬의 교환과정 
  1. 아직 정렬하지 않은 부분에서 가장 작은 키값(a[min])을 선택
  2. a[min]과 아직 정렬하지 않은 부분의 첫번째 요소를 교환
```java
for(int i=0; i < n-1; i++){
    // min = a[i] ... a[n-1] 에서 가장 작은 값을 가지는 요소의 인덱스
    // a[i]와 a[min]의 값을 교환
}
```

### 3. 삽입 정렬(insertion sort)
- 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입'하는 작업을 반복하여 정렬하는 알고리즘
- 단순삽입정렬은 2번째 요소부터 선택하여 진행
```java
for(int i=1; i < n; i++){ // index 1부터 (2번째 요소부터 선택하여 진행)
    // tmp <- a[i]
    // a[0], ... a[i-1] 의 알맞은 곳에 tmp를 삽입   
}
```
- 단순 삽입 정렬 장점 : 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐
- 단순 삽입 정렬 단점 : 삽입할 위치가 멀리 떨어져 있으면 이동(대임)해야하는 횟수가 많아짐

### 4. 셸 정렬(shell sort)
- 단순 삽입 정렬 장점 활용 / 단점 보완하여 더 빠르게 정렬하는 알고리즘

### 5. 퀵 정렬(quick sort)
- 가장 빠른 정렬 알고리즘
- 피벗(pivot) : 그룹을 나누는 기준
- 피벗을 기준으로 배열을 두 그룹으로 나누고,   
각 그룹에 대해 피벗 설정과 그룹나눔을 반복하며 모든 그룹이 1개가 되면 정렬을 마친다

### 6. 병합 정렬(merge sort)
- 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음, 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘   
- 병합정렬 알고리즘의 순서(배열의 요소 개수가 2개 이상인 경우)   
  1.배열의 앞부분을 병합정렬로 정렬   
  2.배열의 뒷부분을 병합정렬로 정렬   
  3.배열의 앞부분과 뒷부분을 병합   


### 7. 힙 정렬(heap sort)
- heap의 특성을 이용하여 정렬하는 알고리즘
- 힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전이진트리다.   
  (부모의 값이 자식보다 항상 작아도 힙이라고 함, 부모와 자식 요소의 관계만 일정하면 됨)

### 8. 도수 정렬(counting sort)


---
## ✅ Arrays.sort
1. 기본 자료형 배열의 정렬(퀵정렬)
2. 클래스 객체 배열의 정렬(병합정렬)
  - 자연 정렬이 필요한 배열 : 요소의 대소관계를 비교하여 정렬   
    static void sort(Object[] a)   
    static void sort(Object[] a, int fromIndex, int toIndex)
  - 자연 정렬이 필요하지 않은 배열 : 요소의 대소관계를 비교할 때 Comparator<T>를 사용하여 정렬   
    static <T> void sort(T[] a, Comparator<? super ?> c)   
    static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super ?> c)
```text
fromIndex == toIndex 이면 정렬범위는 0
fromIndex > toIndex 이면 IllegalArgumentException
fromIndex < 0 또는 toIndex > arr.length 이면 ArrayIndexOutOfBoundsException
```
## ✅ Comparator<T> 사용하기
| 대상                           | 정렬메서드                                  | 내용                     |
|------------------------------|----------------------------------------|------------------------| 
| 배열                           | ```Arrays.sort(Comparator<T> c)```     | 전달받은 배열 자체를 정렬         |
| List, Vector... 등 Collection | ```Collection.sort(Comparator<T> c)``` | 전달받은 Collection 자체를 정렬 |
| Stream                       | ```stream.sorted(Comparator<T> c)```   | 정렬된 Stream을 반환         |

- Comparator<T>는 ```int compare(T obj1, T obj2)``` 메서드를 가지는 제네릭 인터페이스
  - 자바 내장 정렬 메서드들은 compare() 메서드의 반환결과 (값을 비교한 결과)에 따라 정렬한다.
    - 0 : obj1 == obj2
    - 양수 : 왼쪽 객체가 더 크다 → obj1 > obj2
    - 음수 : 오른쪽 객체가 더 크다 → obj1 < obj2

## ✅ Comparable<T> 사용하기
- Comparable<T> : 해당 자료형이 비교할 수 있는 데이터타입이라는 것을 알려주는 인터페이스
- 비교방식을 정의하는 것은 compareTo() 메서드 → <T> 타입의 다른 객체와 자신을 비교한 결과를 반환
- 기본 정렬기준으로 두 객체를 비교해야 한다? → compareTo() 사용하면 됨
- Integer, String 에도 compareTo()가 구현되어있다.
  - Integer 라면 오름차순 정렬됨
  - String 이라면 사전순 정렬됨
